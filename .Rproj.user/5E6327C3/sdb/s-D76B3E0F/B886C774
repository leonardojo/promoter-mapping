{
    "collab_server" : "",
    "contents" : "#Setting directory where LCM-RNAseq norm.counts file are\nsetwd(\"D:/Current Users/Leo Jo/Bioinfo Data/RSMOD PACKAGE VERSION/New Genome/\")\n\n## Setting a cutoff of CPM (Genes that does not contain values above CUTOFF CPM in at least one of the Samples are going to be excluded)\ncountData <- read.csv(\"ordered.allsamples.NormCounts.unfiltered.AVG_v2.0.txt\", sep='\\t', header=T, fill = T, row.names = 1)\n## Removing genes with lower CPM !all(x<=CUTOFF) \ncpm.cutoff <- 0.6 # Here you put what will be your cutoff in CPM\ncountData.cutoff<- countData[apply(countData[,-1], 1, function(x) !all(x<=cpm.cutoff)),] \n\n## -------------------------- Removing Genes with low SAMPLE VARIATION---------------------------\n### Removes the bottom minVarFilter how many  % do you want? (100 - minVarFilter)\nminVarFilter <- 50  \n\nif(is.numeric(minVarFilter)){\n  lowVarCut <- quantile(apply(countData.cutoff,1,var),probs=(minVarFilter/100))\n  keep <- c(1:nrow(countData.cutoff))[apply(countData.cutoff,1,var)>=lowVarCut]\n  countData.cutoff.var <- countData.cutoff[keep,]\n}\n#Do you want to save this table? We use data.origin in saving tables and files so we know where the analysis came from\npercentage.cutoff <- 100 - minVarFilter\ndata.origin <- paste(\"(\",cpm.cutoff,\"cpmcutoff_\",percentage.cutoff,\"Var)\",sep=\"\")\ndata.origin #checking\ndir.create(data.origin) # creating dir with cpm cutoff and var filter information\nsetwd(paste(data.origin)) # setting directory\n#Save tables\nwrite.csv(countData.cutoff.var, paste(data.origin,\"ordered.allsamples.NormCounts.unfiltered.AVG_v2.0.csv\", sep=\"\"), quote=F)\nwrite.csv(countData.cutoff, paste(\"(\",cpm.cutoff,\"cpmCUTOFF)ordered.allsamples.NormCounts.unfiltered.AVG_v2.0.csv\", sep=\"\"), quote=F) \n\n## -------------------------- BH - tSNE (from Steven, with modifications) ---------------------------\n\n#In case you need to install the package -> install.packages(\"RSMod_0.6.0.zip\",repos=NULL, type=\"source\")\n##LIBRARIES ----\n\n## install.packages(\"devtools\")\n## require(devtools)\n## setwd(\"RSMod/\")\n## install(\".\")\n## require(devtools)\n\n\nlibrary(RSMod)\n## install.packages(\"fpc\")\nsetwd(\"C:/Users/leojo/Desktop/RSMod/\")\nlibrary(fpc)\n## install.packages(\"dplyr\")\n## install.packages(\"plyr\")\ninstall.packages(\"Rtsne\")\nlibrary(Rtsne)\nrequire(devtools)\ninstall(\".\")\nlibrary(plyr)\n## install.packages(\"ggplot2\")\nlibrary(ggplot2)\nlibrary(dbscan)\n\noptions(stringsAsFactors  =  FALSE)\n\n## READ IN DATA FILES\n## GENES BY ROW, REPLICATES BY COLUMN, FIRST COLUMN WITH GENE NAMES (row.names = 0)\ndata=read.csv(paste(data.origin,\"ordered.allsamples.NormCounts.unfiltered.AVG_v2.0.csv\", sep=\"\"), header=T) ## PRIMARY DATA.\n#data <- data[,c(47,1:46)]\n# eqtl=read.csv(\".csv\",header=T) ## SUBSETTING DATA IF USED.\n\n# Subset if necessary, this can take some time.\n# (trans=rna.seq data, sub=subset list (Default = no subest)).\ncluster.set=data_norm(trans = data) #, sub = eqtl)\n\n## BH-SNE Mapping ----\n## DATA.SET SHOULD ALWAYS BE cluster.set OUTPUT.\n## PERPLEXITY (perp) IS THE INITIAL GUESS OF AVERAGE SIZE OF NEIGHBORHOOD FOR EACH POINT. RANGES 5-50. \n## INITIAL_DIMS IS CURRENTLY LOCKED AT NUMBER OF DATA FRAME COLUMNS. ADJUSTMENTS IN THE FUTURE.\n## THETA SETS SPEED/ACCURACY (tha). LOWER IS MORE ACCURATE BUT TAKES LONGER.\n## DIMS (dim) IS NUMBER OF FINAL DIMENSIONS. PCA (pc) SETS WHETHER TO DO A PCA ANALYSIS PRIOR TO BH-SNE.\n## SEED (seed) SETS SEED FOR REPRODUCABILITY.\nperpl <- 50 # Perplexity\nitera <- 2000 # Iterations\ncluster.matrix=clusterSNE(data.set=cluster.set,perp=perpl,dim=2,tha=0.3,pc=F,iter=itera,seed=0)\n\n## Module extraction ----\n## (cluster=cluster.matrix,cutoff=number for neighborhood cutoff based on kNNdist - standard is between 1 and 5 for BH-SNE).\n## The desired minpts typically falls on the linear portion of the graph.\n######### Run module number determination script in order to determine the cutoff number #############\ncutoff.m <- 3\nmodules=clusteringOptics(cluster=cluster.matrix,cutoff= cutoff.m) # 3 Default\n\n\n\n## Showtime mapping. ----\n## Color selection and adjustment coming soon.\nshowtimeMapping(base=cluster.matrix,clusters=modules)\n\n## Extracting total number of clusters.\n## Not required.\n# numberClust=max(as.numeric(network$colors))\n\n## Single/Multi module overlay. ----\n## Base = original BH-SNE output, overlay = ,n = # of modules (max of 4)\nModOverlay(base=cluster.matrix,clusters=modules,n=2)\n\n## Important part for organization (add the number of parameters you used ) ####\nreference <- paste(\"(\",itera,\"iter.\",perpl,\"perp.\",cutoff.m,\"cutoff)\", sep=\"\") # This is important for organization purposes\nreference #checking\n\n## Saving Module List ----\ndir.create(paste(reference)) #Creating a folder to save everything\nsetwd(paste(reference))\nwrite.csv(modules,paste(reference,\"Module List.csv\", sep=\"\"))\n\n## Overlaying specific genes onto the map.\n## Still in beta.\n# overMap=read.csv(\"lit curated list short.csv\",header=T)\n# indOver(set=overMap,overlay=modules)\n\n\n## -------------------------- Creating table for each module ----------------------------------------------\n## What information is going to be in the table?\n## Gene List with their log2 ratio normalization across all samples\n\n#Log2 ration normalization of original data\ndata.Norm <- data[,-1] # Taking the gene name column\nrow.names(data.Norm) <- data$X # Assigning Gene to row names\ndata.Norm[data.Norm==0] <- 1e-10 # Replacing Zeros\ndata.Norm <- log2(data.Norm/apply(data.Norm,1,mean)) # Calculating sqrt Ratio\n\nrow.names(data) <- data$X\n\n#Adding Normalized expression data into\ndir.create(\"Modules\") # Creating a folder where modules will be saved\nfor( i in c(1:length(unique(modules$color)))){ #length(unique(modules$color)) will tell how many modules you have\n  \n  y <- subset(modules, modules$color==i)\n  y.2 <- merge(data, y, by= \"row.names\")\n  y.2 <- na.omit(y.2)\n  row.names(y.2) <- y.2$row.names\n  y.2 <- y.2[,-2]\n  y.2 <- y.2[,1:47]\n  write.table(y.2,paste(\"Modules/Module\", i, \".txt\", sep=\"\"), sep=\"\\t\", col.names=T, row.names=F, quote=F)\n}\n\n## -------------------------- Creating table for PROFILES ----------------------------------------------\n## What information is going to be in the table?\n## The MEDIAN off the log2 ratio of each module\n## Module ----- Sample1 ----- Sample2 ----- Sample3 ------ ...\n##   1           median        median        median        ...\n##   2           median        median        median        ...\n\n## Creating an empty matrix with nrow = number of modules and ncol = number of samples \nprofiles <- matrix(data=0,ncol=ncol(data.Norm),nrow=(as.numeric(length(unique(modules$color)))-1)) #nrow = number of profiles\n\n### Opening each module table + Calculating the MEDIAN of each column + Adding them to the profile table\nfor( i in c(1:length(unique(modules$color)))){\n  \n  z <- read.table(paste(\"Modules/Module\", i, \".txt\", sep=\"\"), sep=\"\\t\", header= T, row.names =1)\n  z[z==0] <- 1e-10 # Replacing Zeros\n  z <- log2(z/apply(z,1,mean)) # Calculating sqrt Ratio\n  profiles[i,] <- as.numeric(apply(z,2,median))\n}\n## Error message is OK, that's because the last module is EMPTY\n\n### Formating the table and saving it\nprofiles <- data.frame(profiles)\ncolnames(profiles) <- colnames(data.Norm) # Changing Column names\nprofiles$Module <- 1:(as.numeric(length(unique(modules$color)))-1) # Addint Module Column\nprofiles <- profiles[,c(47,1:46)] # Moving Module Column to the Front\n\n#Saving Profile table\nwrite.csv(profiles, paste(reference,\"profiles.csv\",sep=\"\"), quote=F, row.names=F)\n\n## -------------------------- Creating Bar Plots of each Module ----------------------------------------------\n## What information is going to be in the PLOT?\n## The MEDIAN off the log2 ratio of each module\n\n## Library\nlibrary(plyr)\n\n#Taking the module column from the Profile Table\nprofiles2 <- profiles[,-1]\n#Transpose profiles2 table\nt.profiles <- t(profiles2)\n#2^Log2 ratio\nt.profiles <- 2^t.profiles\nnames <- row.names(t.profiles)\n\n#Creating and saving plots files will be in the Barplots Folder\nfor( i in c(1:length(unique(modules$colors)))){\n  jpeg(paste(\"Modules/Module\", i,\"barplot(log2).jpeg\", sep=\"\"), width = 1000, height = 500)\n  par(mar=c(8,4.1,8,2.1))\n  barplot(t.profiles[,i], main=paste(reference,\"Module\",i), names.arg = names,las = 3, xpd = F, ylab = \"Normalized Expression\", col= c(rep(\"lightgreen\",3), rep(\"darkolivegreen1\",9),rep(\"lawngreen\", 7), rep(\"darkgreen\", 3), rep(\"red\",4),rep(\"khaki\",4), rep(\"yellow\",4), rep(\"orange2\", 6), rep(\"tomato1\",3), rep(\"coral4\", 3)))\n  dev.off()\n}\n\n## --------------------------- LINE PLOTS ------------------------\n\n## --------------------------- GENE ONTOLOGY ENRICHMENT ANALYSIS ---------------------------\n#This is for subregions specific expression genes GO terms enrichment.\n#three type of GO terms test independent.\n#Do hypergeometric and FDR adjust.\n\n## Library\nsource(\"https://bioconductor.org/biocLite.R\")\nbiocLite(\"goseq\")\nlibrary(goseq)\n#library(RamiGO)\n\n#read all the table. \nsetwd(\"D:/Current Users/Leo Jo/Bioinfo Data/GO/Gmax2/\") # setting the directory where the files are\nall.genes<-read.table(\"Gmax_275_Gene_Model.lengths.txt\", sep=\"\\t\",stringsAsFactors=FALSE, header=FALSE)\nGO_BP<-read.table(\"Glyma2.0_soybase_genome_annotation_07-09-2015.splitGO.txt\", sep=\"\\t\",stringsAsFactors=FALSE)\nGO_MF<-read.table(\"Glyma2.0_soybase_genome_annotation_07-09-2015.splitMolecular.txt\", sep=\"\\t\",stringsAsFactors=FALSE)\nGO_CC<-read.table(\"Glyma2.0_soybase_genome_annotation_07-09-2015.splitCellular.txt\", sep=\"\\t\",stringsAsFactors=FALSE)\ntermfile<-read.table(\"GOterm.txt\", sep=\"\\t\", stringsAsFactors=FALSE,header=FALSE,fill=TRUE,quote=\"\")\nanno<-read.table(\"Glyma2.0_soybase_annotation_20150722_maybefixed.txt\",sep=\"\\t\",header=TRUE,stringsAsFactors=FALSE,fill=TRUE,quote=\"\")\n\n#this creates a vector with all the genes to assay\nassayed.genes<-all.genes$V1\ngene.length<-as.integer(all.genes$V2)\nnames(gene.length)<-assayed.genes\n\n#List all the gene files in the directory\nsetwd(\"D:/Current Users/Leo Jo/Bioinfo Data/RSMOD PACKAGE VERSION/New Genome/\")\nsetwd(paste(data.origin,\"/\",reference,\"/Modules\",sep=\"\"))\nfilelist=list.files(pattern=\".txt\")\nfilelist=filelist[file.info(filelist)$size>0]\n\n#Start analysis.\nfor (i in filelist){\n  de.genes=read.table(i,sep=\"\\t\",stringsAsFactors=FALSE,header=TRUE)\n  de.genes=de.genes[,1]\n  gene.vector<-as.integer(assayed.genes%in%de.genes)\n  names(gene.vector)=assayed.genes\n  \n  pwf<-nullp(gene.vector,bias.data=gene.length,plot.fit=F)\n  \n  #GO terms enrichment of Biological Process\n  go.wall.BP <- goseq(pwf,gene2cat=GO_BP,method=\"Hypergeometric\", use_genes_without_cat=T)\n  go.wall.BP$qval <- p.adjust(go.wall.BP$over_represented_pvalue,method=\"BH\")\n  enriched.go.BP <-subset(go.wall.BP, go.wall.BP$qval < 0.05)\n  \n  #if have Go terms qval lower than 0.05, draw a tree.\n  if(nrow(enriched.go.BP)>0){\n    #     goIDs=enriched.go.BP[,1]\n    #     pvalues=enriched.go.BP[,4]\n    #     name=paste(colnames(genesToPatterns)[i],\".GOseq.enrichment.BP\",sep=\"\")\n    #     pngRes <- getAmigoTree(goIDs=goIDs,pvalues=pvalues,pcolors=c(\"white\",\"red\"),\n    #                            psplit=c(1,0.1,0.01,0.001,0.0001,0.00001,0.000001),filename=name)\n    #  }   \n    #enriched.go.wall.annot.BP <-merge(enriched.go.BP,termfile,by.x=\"category\",by.y=\"V1\",all.x=TRUE)\n    enriched.go.wall.annot.BP=enriched.go.BP\n    #enriched.go.wall.annot.BP[,c(1,2,4,5,6,7,8)]\n    \n    #for table\n    Data1=NULL\n    for(j in c(1:nrow(enriched.go.wall.annot.BP))){\n      referencesGenes=GO_BP[GO_BP[,2]==enriched.go.wall.annot.BP[j,1],1]\n      NumberOfReferencesGenes=length(referencesGenes)\n      Genes=intersect(referencesGenes,de.genes)\n      entries=NULL\n      for(k in c(1:length(Genes))){\n        entries=paste(entries,Genes[k],sep=\",\")\n      }\n      entries=substr(entries,2,nchar(entries))\n      NumberOfGenes=length(Genes)\n      Data2=cbind(NumberOfGenes,NumberOfReferencesGenes,entries)\n      Data1=rbind(Data1,Data2)\n    }\n    enriched.go.wall.annot.BP=cbind(enriched.go.wall.annot.BP,Data1)\n    enriched.go.wall.annot.BP=enriched.go.wall.annot.BP[order(enriched.go.wall.annot.BP$qval),]\n  }\n  if(nrow(enriched.go.BP)==0){\n    enriched.go.wall.annot.BP=NULL\n  }\n  \n  #GO terms enrichment of molecular function.\n  go.wall.MF <- goseq(pwf,gene2cat=GO_MF,method=\"Hypergeometric\", use_genes_without_cat=T)\n  go.wall.MF$qval <- p.adjust(go.wall.MF$over_represented_pvalue,method=\"BH\")\n  enriched.go.MF <-subset(go.wall.MF, go.wall.MF$qval < 0.05)\n  \n  #if have Go terms qval lower than 0.05, draw a tree.\n  if(nrow(enriched.go.MF)>0){\n    #     goIDs=enriched.go.MF[,1]\n    #     pvalues=enriched.go.MF[,4]\n    #     name=paste(colnames(genesToPatterns)[i],\".GOseq.enrichment.MF\",sep=\"\")\n    #     pngRes <- getAmigoTree(goIDs=goIDs,pvalues=pvalues,pcolors=c(\"white\",\"red\"),\n    #                            psplit=c(1,0.1,0.01,0.001,0.0001,0.00001,0.000001),filename=name)\n    \n    \n    #enriched.go.wall.annot.MF <-merge(enriched.go.MF,termfile,by.x=\"category\",by.y=\"V1\",all.x=TRUE)\n    enriched.go.wall.annot.MF=enriched.go.MF\n    #enriched.go.wall.annot.MF[,c(1,2,4,5,6,7,8)]\n    \n    #for table\n    Data1=NULL\n    for(j in c(1:nrow(enriched.go.wall.annot.MF))){\n      referencesGenes=GO_MF[GO_MF[,2]==enriched.go.wall.annot.MF[j,1],1]\n      NumberOfReferencesGenes=length(referencesGenes)\n      Genes=intersect(referencesGenes,de.genes)\n      entries=NULL\n      for(k in c(1:length(Genes))){\n        entries=paste(entries,Genes[k],sep=\",\")\n      }\n      entries=substr(entries,2,nchar(entries))\n      NumberOfGenes=length(Genes)\n      Data2=cbind(NumberOfGenes,NumberOfReferencesGenes,entries)\n      Data1=rbind(Data1,Data2)\n    }\n    enriched.go.wall.annot.MF=cbind(enriched.go.wall.annot.MF,Data1)\n    enriched.go.wall.annot.MF=enriched.go.wall.annot.MF[order(enriched.go.wall.annot.MF$qval),]\n  }\n  if(nrow(enriched.go.MF)==0){\n    enriched.go.wall.annot.MF=NULL\n  }\n  \n  #GO terms enrichment of Cellular component.\n  go.wall.CC <- goseq(pwf,gene2cat=GO_CC,method=\"Hypergeometric\", use_genes_without_cat=T)\n  go.wall.CC$qval <- p.adjust(go.wall.CC$over_represented_pvalue,method=\"BH\")\n  enriched.go.CC <-subset(go.wall.CC, go.wall.CC$qval < 0.05)\n  \n  #   #if have Go terms qval lower than 0.05, draw a tree.\n  if(nrow(enriched.go.CC)>0){\n    #     goIDs=enriched.go.CC[,1]\n    #     pvalues=enriched.go.CC[,4]\n    #     name=paste(colnames(genesToPatterns)[i],\".GOseq.enrichment.cc\",sep=\"\")\n    #     pngRes <- getAmigoTree(goIDs=goIDs,pvalues=pvalues,pcolors=c(\"white\",\"red\"),\n    #                            psplit=c(1,0.1,0.01,0.001,0.0001,0.00001,0.000001),filename=name)\n    \n    \n    #enriched.go.wall.annot.CC <-merge(enriched.go.CC,termfile,by.x=\"category\",by.y=\"V1\",all.x=TRUE)\n    enriched.go.wall.annot.CC=enriched.go.CC\n    #enriched.go.wall.annot.CC[,c(1,2,4,5,6,7,8)]\n    \n    #for table\n    Data1=NULL\n    for(j in c(1:nrow(enriched.go.wall.annot.CC))){\n      referencesGenes=GO_CC[GO_CC[,2]==enriched.go.wall.annot.CC[j,1],1]\n      NumberOfReferencesGenes=length(referencesGenes)\n      Genes=intersect(referencesGenes,de.genes)\n      entries=NULL\n      for(k in c(1:length(Genes))){\n        entries=paste(entries,Genes[k],sep=\",\")\n      }\n      entries=substr(entries,2,nchar(entries))\n      NumberOfGenes=length(Genes)\n      Data2=cbind(NumberOfGenes,NumberOfReferencesGenes,entries)\n      Data1=rbind(Data1,Data2)\n    }\n    enriched.go.wall.annot.CC=cbind(enriched.go.wall.annot.CC,Data1)\n    enriched.go.wall.annot.CC=enriched.go.wall.annot.CC[order(enriched.go.wall.annot.CC$qval),]\n  }\n  if(nrow(enriched.go.CC)==0){\n    enriched.go.wall.annot.CC=NULL\n  }\n  \n  if(nrow(enriched.go.BP)+nrow(enriched.go.CC)+nrow(enriched.go.MF)>0){\n    enriched.go.wall.annot=NULL\n    enriched.go.wall.annot=rbind(enriched.go.wall.annot.BP,enriched.go.wall.annot.MF,enriched.go.wall.annot.CC)\n    enriched.go.wall.annot<- enriched.go.wall.annot[,-c(2:5)]\n    name=paste(substr(i,1,nchar(i)-4),\"GOseq.enrichment.txt\",sep=\".\")\n    write.table(enriched.go.wall.annot,name,sep=\"\\t\",quote=FALSE,row.names=F)\n  }\n}\n\n## --------------------------- Creating a Annotation table for each Module ----------------------------------\n\n## anno<-read.table(\"GeneAnnotation_Gmax189.txt\",sep=\"\\t\",header=TRUE,stringsAsFactors=FALSE,fill=TRUE,quote=\"\")\nrow.names(anno) <- anno$Glyma.ID\n\nfor( i in c(1:length(unique(modules$colors)))){\n  module.anno <-read.table(paste(\"Module\",i,\".txt\",sep=\"\") , sep=\"\\t\", header=TRUE,stringsAsFactors=FALSE,fill=TRUE,quote=\"\", row.names=1)\n  module.anno.list <- merge(module.anno, anno, by.x=\"row.names\", by.y= \"Gmax.2.0.Primary.Protein.ID\", all.x=T) # Merging two tables\n  module.anno.list <- module.anno.list[,-c(2:47)] # Excluding expression data\n  write.csv(module.anno.list, paste(\"Module\",i,\".annotation.csv\",sep=\"\"), row.names=F, quote = F)\n}\n",
    "created" : 1497058190642.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2808297537",
    "id" : "B886C774",
    "lastKnownWriteTime" : 1497046620,
    "last_content_update" : 1497046620,
    "path" : "D:/Current Users/Leo Jo/Bioinfo Data/RSMOD PACKAGE VERSION/New Genome/BH-SNE (LJ-FULL) (Glyma2.0).R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}